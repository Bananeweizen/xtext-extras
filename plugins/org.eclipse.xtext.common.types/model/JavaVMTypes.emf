@namespace(uri="http://www.eclipse.org/xtext/common/JavaVMTypes", prefix="types")
package types;

abstract class IdentifyableElement {
  op String getCanonicalName();
}

abstract class Type extends IdentifyableElement {
/*
  op boolean isValidReturnType();
  op boolean isValidParameterType();
  op boolean isValidTypeArgument();
*/
}

class Void extends Type {
}

abstract class ComponentType extends Type {
  val ArrayType arrayType;
}

class PrimitiveType extends ComponentType {
  attr String name;
}

class ArrayType extends ComponentType {
  op int getDimensions();
  val TypeReference componentType;
}

abstract class DeclaredType extends ComponentType, Member {
  op String getPackageName();
  val TypeReference[*] superTypes;
  val Member[*]#declaringType members;
}

class TypeParameter extends ComponentType, ConstraintOwner {
  attr String name;
  ref TypeParameterDeclarator#typeParameters declarator;
}

abstract class TypeParameterDeclarator {
  val TypeParameter[*]#declarator typeParameters;
}

abstract class ConstraintOwner extends IdentifyableElement {
  op String getCanonicalName();
  val TypeConstraint[*]#owner constraints;
}

abstract class TypeConstraint extends IdentifyableElement {
  val TypeReference typeReference;
  ref ConstraintOwner#constraints owner;
}

class UpperBound extends TypeConstraint {
}

class LowerBound extends TypeConstraint {
}

class AnnotationType extends DeclaredType {
}

class EnumerationType extends DeclaredType {
}

class GenericType extends DeclaredType, TypeParameterDeclarator {
  attr boolean ~abstract;
  attr boolean ~interface;
  attr boolean static;
  attr boolean final;
  op Iterable<Type> getExtendedInterfaces();
  op Iterable<Type> getExtendedClasses();
  op boolean isInstantiateable(); 
}

abstract class TypeReference extends IdentifyableElement {
  op Type getType();
}

class ParameterizedTypeReference extends TypeReference {
//  attr String fullyQualifiedName;
  val TypeArgument[*]#declarator arguments;
  ref Type type;
}

class GenericArrayTypeReference extends TypeReference {
  val ArrayType type;  
}

abstract class TypeArgument extends IdentifyableElement {
  ref ParameterizedTypeReference#arguments declarator;
}

class WildcardTypeArgument extends TypeArgument, ConstraintOwner {
}

class ReferenceTypeArgument extends TypeArgument {
  val TypeReference typeReference;
}

abstract class Member extends AnnotationTarget, IdentifyableElement {
  ref DeclaredType#members declaringType;
  attr Visibility visibility;
  attr String fullyQualifiedName;
  op String getSimpleName();
}

enum Visibility {
  DEFAULT = 0;
  PRIVATE = 1;
  PROTECTED = 2;
  PUBLIC = 3;
}

class Field extends Member {
  attr boolean static;
  attr boolean final;
  val TypeReference type;
}

abstract class Executable extends Member, TypeParameterDeclarator {
  val FormalParameter[*] parameters;
  val TypeReference[*] exceptions;
}

class Constructor extends Executable {
}

class Operation extends Executable {
  attr boolean static;
  attr boolean final;
  attr boolean ~abstract;
  val TypeReference returnType;
}

class FormalParameter extends IdentifyableElement {
  attr String name;
  val TypeReference parameterType;
}

abstract class AnnotationTarget {
  val AnnotationReference[*]#target annotations;
}

class AnnotationReference {
  ref AnnotationType annotation;
  ref AnnotationTarget#annotations target;
}

// important note: unfortunatly, emfatic does not support 
// generified datatypes, that's why you'll have to uncomment /
// comment the next lines and add the parameter type manually
datatype Iterable<E> : java.lang.Iterable;
// datatype Iterable : java.lang.Iterable;
