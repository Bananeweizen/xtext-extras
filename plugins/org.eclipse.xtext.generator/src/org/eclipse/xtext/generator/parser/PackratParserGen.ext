/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
import xtext;
import xtextgen;
import predicate;
import emf;
import oaw;

extension org::eclipse::xtext::GrammarUtil reexport;
extension org::eclipse::xtext::generator::grammarAccess::GrammarAccess;
extension org::eclipse::xtext::generator::Naming;

cached String getParserClassName(Grammar this) :
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getGeneratedParser(org.eclipse.xtext.Grammar);

cached String consumeMethodName(AbstractElement this):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getConsumeMethodName(org.eclipse.xtext.AbstractElement);

cached String delimiterFieldName(AbstractElement this):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getDelimiterFieldName(org.eclipse.xtext.AbstractElement);

cached String consumerFieldName(AbstractElement this):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getConsumerFieldName(org.eclipse.xtext.AbstractElement);
	
cached String globalDelimiterFieldName(AbstractElement this):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getGlobalDelimiterFieldName(org.eclipse.xtext.AbstractElement);
			
cached String consumerClassName(AbstractRule this):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getConsumerClassName(org.eclipse.xtext.AbstractRule);
	
cached String getParserConfigurationClassName(Grammar this) :
	name.toJavaPackage()+".parser.packrat."+name.toSimpleName()+"ParserConfiguration";
	
cached String getDelimiterClassName(Grammar this) :
	name.toJavaPackage()+".parser.packrat."+name.toSimpleName()+"Delimiters";

cached String consumerInterfaceName(AbstractRule this):
	"ITerminalConsumer";

cached String consumerInterfaceName(ParserRule this):
	if (terminal) then "ITerminalConsumer" else "INonTerminalConsumer";
			
cached String consumerFieldName(AbstractRule this):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getConsumerFieldName(org.eclipse.xtext.AbstractRule);

String consumerSetterName(AbstractRule this):
	"set" + consumerFieldName().toFirstUpper();
	
String consumerGetterName(AbstractRule this):
	"get" + consumerFieldName().toFirstUpper();
	
String consumerPackageName(AbstractRule this):
	containingGrammar().getNamespace() + ".parser.packrat.consumers";	

String fullConsumerClassName(AbstractRule this):
    consumerPackageName() + "." + consumerClassName();
    
String grammarAccess(Grammar this):
    gaFQName();
    
String toJavaString(String this):
	JAVA org.eclipse.xtext.util.Strings.convertToJavaString(java.lang.String);
   
/* boolean canBeFollowedByIdentifier(Keyword this):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.canBeFollowedByIdentifier(org.eclipse.xtext.Keyword); */

cached List[Keyword] conflictingKeywords(AbstractElement this, Grammar grammar):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getConflictingKeywords(org.eclipse.xtext.AbstractElement, org.eclipse.xtext.Grammar);

cached List[AbstractRule] conflictingLexerRules(Keyword this, Grammar grammar):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.getConflictingLexerRules(org.eclipse.xtext.Keyword, org.eclipse.xtext.Grammar);

cached AbstractElement sameConflicts(AbstractElement this, Grammar grammar):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.findFirstWithSameConflicts(org.eclipse.xtext.AbstractElement, org.eclipse.xtext.Grammar);

cached Keyword sameConflicts(Keyword this, Grammar grammar):
	JAVA org.eclipse.xtext.generator.parser.PackratParserGenUtil.findFirstKeywordWithSameConflicts(org.eclipse.xtext.Keyword, org.eclipse.xtext.Grammar);
		
boolean isPlus(AbstractElement this):
	!isOptionalCardinality() && isMultipleCardinality();

boolean isStar(AbstractElement this):
	isOptionalCardinality() && isMultipleCardinality();
	
boolean isQuestionMark(AbstractElement this):
	isOptionalCardinality() && !isMultipleCardinality();
	
int indexInGroup(AbstractElement element, Group parent):
    parent.abstractTokens.flattendGroupElements().indexOf(element);
    
cached List[AbstractElement] flattendGroupElements(Group this):
	if(!isOptionalCardinality() && !isMultipleCardinality()) then abstractTokens.flattendGroupElements() else this;

List[AbstractElement] flattendGroupElements(AbstractElement this):
	this;
		
int indexInAlternatives(AbstractElement element, Alternatives parent):
    parent.groups.flattendAlternativesElements().indexOf(element);
    
cached List[AbstractElement] flattendAlternativesElements(Alternatives this):
	if(!isOptionalCardinality() && !isMultipleCardinality()) then groups.flattendAlternativesElements() else this;

List[AbstractElement] flattendAlternativesElements(AbstractElement this):
	{this};
	
cached List[AbstractElement] allDelimited(AbstractRule this):
	containedRuleCalls().select(e|e.rule.metaType==LexerRule || (e.rule.metaType == ParserRule && ((ParserRule)e.rule).terminal)).
		union(eAllContents.typeSelect(Keyword)).
		union(eAllContents.typeSelect(CrossReference).select(e|e.rule.metaType==LexerRule || (e.rule.metaType == ParserRule && ((ParserRule)e.rule).terminal)))
	.toSet().sortBy(e|e.globalDelimiterFieldName());
	
cached List[AbstractRule] allCalledRules(AbstractRule this):
	containedRuleCalls().rule.union(eAllContents.typeSelect(CrossReference).rule).toSet().sortBy(e|e.consumerFieldName());