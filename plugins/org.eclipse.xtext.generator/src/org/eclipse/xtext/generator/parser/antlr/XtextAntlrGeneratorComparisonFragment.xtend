/*******************************************************************************
 * Copyright (c) 2015 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package org.eclipse.xtext.generator.parser.antlr

import com.google.common.base.Stopwatch
import com.google.common.io.Files
import com.google.inject.Inject
import java.io.File
import java.nio.charset.Charset
import java.util.List
import java.util.concurrent.TimeUnit
import java.util.regex.Matcher
import java.util.regex.Pattern
import org.eclipse.xpand2.XpandExecutionContextImpl
import org.eclipse.xpand2.XpandFacade
import org.eclipse.xtend.lib.annotations.Accessors
import org.eclipse.xtext.Grammar
import org.eclipse.xtext.generator.Generator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.adapter.FragmentAdapter
import org.eclipse.xtext.util.internal.Log
import org.eclipse.xtext.xtext.FlattenedGrammarAccess
import org.eclipse.xtext.xtext.RuleFilter
import org.eclipse.xtext.xtext.RuleNames
import org.eclipse.xtext.xtext.generator.Issues
import org.eclipse.xtext.xtext.generator.parser.antlr.GrammarNaming

/**
 * Compares the Antlr grammar generated by {@link 
 * org.eclipse.xtext.xtext.generator.parser.antlr.XtextAntlrGeneratorFragment2
 * XtextAntlrGeneratorFragment2} with that of {@link XtextAntlrGeneratorFragment}
 * by running its grammar generation in a temporary folder and comparing the
 * grammar outputs token by token.
 * 
 * @author Christian Schneider - Initial contribution and API
 * @since 2.9
 */
 @Log
class XtextAntlrGeneratorComparisonFragment extends FragmentAdapter {

	private static val ENCODING = 'ISO-8859-1'
	
	private static val SINGLE_CHAR_TOKENS = #[
		'\\(', '\\)', '\\[', '\\]', '\\{', '\\}', '\\|', '=', ':', ';'
	]
	
	// quoted tokens are those like in '\'' or '\'\'\'' occurring in the Xtend grammar,
	//  and arbitrary charSequences enclosed in single quotes or double quotes
	private static val QUOTED_TOKENS = #[
		"'(\\\\')+'", "('[^']*')", '("[^"]*")'
	].join('|')
	
	// valid tokens are those mentioned in SINGLE_CHAR_TOKENS and those described in QUOTED_TOKENS,
	// as well as character sequences containing no white space (\s), no single quotes ('),
	//  no double quotes ("), and none of SINGLE_CHAR_TOKENS 
	private static val TOKEN = '''«SINGLE_CHAR_TOKENS.join('|')»|«QUOTED_TOKENS»|[^\s'"«SINGLE_CHAR_TOKENS.join»]+''';
	
	// platform neutral definition of newline tokens, they are distinguished for counting lines
	private static val NEWLINE = "\\r?\\n|\\r"
	
	// other white space to be ignored, is distinguished for testing for any unmatched character sequences
	private static val WS = "( |\\t)+"		
	
	private val p_token = Pattern.compile(TOKEN)
	private val p_newline = Pattern.compile(NEWLINE)
	private val p_ws = Pattern.compile(WS)
	private val compoundPattern = Pattern.compile('''(«TOKEN»)|(«NEWLINE»)|(«WS»)''', Pattern.MULTILINE) 		

	@Inject
	extension GrammarNaming

	@Accessors
	AntlrOptions options

	@Accessors
	boolean partialParsing;

	@Accessors
	boolean skipContentAssistGrammarComparison = false

	private List<String> advices = newArrayList()

	public def void addRegisterAdvice(String advice) {
		advices += advice;
	}

	override checkConfiguration(Issues issues) {
	}

	override generate() {
		if (naming === null)
			naming = createNaming()
		
		if (options === null)
			options = new AntlrOptions
			
		if (projectConfig.runtime?.srcGen != null) {
			projectConfig.runtime.srcGen.loadAndCompareGrammars(Generator.SRC_GEN,
				'''«grammar.grammarClass.path».g'''
			)
		}
		
		if (!skipContentAssistGrammarComparison && projectConfig.genericIde?.srcGen != null) {
			projectConfig.genericIde.srcGen.loadAndCompareGrammars(Generator.SRC_GEN_IDE,
				// TODO to be updated once the new content assist grammar generator is available
				'''«grammar.getInternalContentAssistLexerClass.path.replaceFirst("Lexer$","")».g'''
			)
		}
				
		deleteDir(tmpDir)
	}

	protected def loadAndCompareGrammars(IFileSystemAccess2 fsa, String outlet, String grammarFileName) {
		val stopWatch = Stopwatch.createStarted

		outlet.performXpandBasedGeneration()
		
		
		val absoluteGrammarFileName = '''«fsa.path»/«grammarFileName»'''
		val absoluteGrammarFileNameReference = '''«getTmpDir().absolutePath»/«grammarFileName»'''
		
		val grammar = fsa.readTextFile(grammarFileName)
		val grammarReference = Files.toString(new File(absoluteGrammarFileNameReference), Charset.forName(ENCODING))
		
		val lines = compareGrammars(grammar, grammarReference, absoluteGrammarFileName, absoluteGrammarFileNameReference)
		
		val time = stopWatch.elapsed(TimeUnit.MILLISECONDS)
		
		val type = if (outlet === Generator.SRC_GEN) "parser" else "content assist" 
		
		LOG.info('''Generated «type» grammar of «lines.key» lines matches expected one of «lines.value» («time» ms).''')
				
	}

	def protected void performXpandBasedGeneration(String outlet) { 
		val RuleFilter filter = new RuleFilter();
		filter.setDiscardUnreachableRules(options.isSkipUnusedRules());
		
		val RuleNames ruleNames = RuleNames.getRuleNames(grammar, true);
		val Grammar flattened = new FlattenedGrammarAccess(ruleNames, filter).getFlattenedGrammar();
		
		val context = createExecutionContext() as XpandExecutionContextImpl;
		
		advices.forEach[
			context.registerAdvices(it);
		];
		
		if (outlet == Generator.SRC_GEN
					&& context.output.getOutlet(Generator.SRC_GEN) != null) {
			val template = XtextAntlrGeneratorFragment.getName().replaceAll("\\.", "::");
			XpandFacade.create(context).evaluate2(template + "::generate", flattened, #[ options ]);
			
		} else if (outlet == Generator.SRC_GEN_IDE
					&& context.output.getOutlet(Generator.SRC_GEN_IDE) != null) {
			val template = XtextAntlrUiGeneratorFragment.getName().replaceAll("\\.", "::");
			XpandFacade.create(context).evaluate2(template + "::generate", flattened, #[
				options, partialParsing, naming.hasIde
			]);
		}
	}

	private int newlineCounter
	private int newlineCounterReference

	/**
	 * Performs the actual comparison of given and expected grammar.
	 * 
	 * @return {@link Pair} containing the number of lines of the tested grammar (key)
	 * 			and the referenced grammar (value) for logging purposes
	 */
	protected def compareGrammars(CharSequence grammar, CharSequence grammarReference,
			String absoluteGrammarFileName, String absoluteGrammarFileNameReference) {

		val compoundMatcher = compoundPattern.matcher(grammar)
		val compoundMatcherReference = compoundPattern.matcher(grammarReference)
		
		newlineCounter = 1
		newlineCounterReference = 1
		
		// these values are used to check whether any character sequences have not been matched
		var previousEnd = 0;
		var previousEndReference = 0;
		
		val ()=>void missedCharSequenceHandler = [
			copyFile(absoluteGrammarFileNameReference, absoluteGrammarFileName)
			handleUnexpectedCharSequence(absoluteGrammarFileName, newlineCounter)
		]
		val ()=>void missedCharSequenceHandlerReference = [			
			copyFile(absoluteGrammarFileNameReference, absoluteGrammarFileName)
			handleUnexpectedCharSequence(absoluteGrammarFileNameReference, newlineCounterReference)
		]
		
		var continue = compoundMatcher.find && compoundMatcherReference.find 
		
		while (continue) {
			val res = compoundMatcher.nextToken(previousEnd, missedCharSequenceHandler)
			newlineCounter += res
			if (!compoundMatcher.hitEnd) {
				previousEnd = compoundMatcher.end
			}
			 
			val resReference = compoundMatcherReference.nextToken(previousEndReference, missedCharSequenceHandlerReference)	
			newlineCounterReference += resReference
			if (!compoundMatcherReference.hitEnd) {
				previousEndReference = compoundMatcherReference.end
			}
			
			var match = if (compoundMatcher.hitEnd) "««eof»»" else compoundMatcher.group
			var matchReference = if (compoundMatcherReference.hitEnd) "««eof»»" else compoundMatcherReference.group
			
			if (matchReference != match) {
				handleMismatch(absoluteGrammarFileName, absoluteGrammarFileNameReference,
					match, matchReference, newlineCounter, newlineCounterReference
				)
			}
			
			continue = continue && compoundMatcherReference.find && compoundMatcher.find
		}
		
		return Pair.of(newlineCounter, newlineCounterReference)
	}
	
	/**
	 * continue matching until the next token is found, count newlines while doing so.
	 * 
	 * @return the number of newlines passed while searching 
	 */
	def private nextToken(Matcher matcher, int previousEnd, ()=> void missedCharSequenceHandler) {
		var continue = true;
		var newlineCounter = 0;
		var thePreviousEnd = previousEnd
		
		while (continue) {
			if (matcher.start() != thePreviousEnd) {
				missedCharSequenceHandler.apply()
			}
			
			val match = matcher.group()
			
			if (p_newline.matcher(match).matches()) {
				// in case the 'newline' pattern matches the found 'match' ...
				newlineCounter++
				thePreviousEnd = matcher.end
				
			} else if (p_ws.matcher(match).matches) {
				thePreviousEnd = matcher.end
				
			} else if (p_token.matcher(match).matches()) {
				// in case a valid token has been found stop here
				return newlineCounter
			}
			
			continue = matcher.find()
		}
		
		return newlineCounter
	}

	protected def handleUnexpectedCharSequence(String absoluteGrammarFileName, int lineNo) {
		deleteDir(tmpDir)
		
		throw new RuntimeException('''
			Noticed an unmatched character sequence in file «absoluteGrammarFileName» in/before line «lineNo».
		''')
	}

	protected def handleMismatch(String absoluteGrammarFileName, String absoluteGrammarFileNameReference,
			String match, String matchReference, int lineNo, int lineNoReference) {
		copyFile(absoluteGrammarFileNameReference, absoluteGrammarFileName)
		
		deleteDir(tmpDir)
		
		throw new RuntimeException('''
			Generated grammar «absoluteGrammarFileName» differs at token «match» (line «lineNo
				»), expected token «matchReference» (line «lineNoReference»).''')
	}
	
	protected def copyFile(String from, String to) {
		Files.copy(
			new File(from),
			new File('''«to.substring(0, to.length - 2)»Expected.g''')
		)
	}

	/**
	 * offers a singleton temporary folder 
	 */
	private def File create path: Files.createTempDir() getTmpDir() {
	}

	/**
	 * Tweaks the generation of the {@link Generator#SRC_GEN Generator.SRC_GEN} outlet
	 * and injects the {@link #getTmpPath()}.
	 */
	override protected createOutlet(boolean append, String encoding, String name, boolean overwrite, String path) {
		if (name == Generator.SRC_GEN || name == Generator.SRC_GEN_IDE || name == Generator.SRC_GEN_UI) {
			super.createOutlet(append, encoding, name, overwrite, getTmpDir().absolutePath)			
		} else {			
			super.createOutlet(append, encoding, name, overwrite, path)
		}
	}

	/** little helper for cleaning up the temporary stuff. */
    private static def void deleteDir(File dir) {
        if (!dir.exists) {
            return;
        }

        Files.fileTreeTraverser.postOrderTraversal(dir).forEach[
        	delete()
        ]
    }
}
