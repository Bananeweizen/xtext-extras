/*******************************************************************************
 * Copyright (c) 2015 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package org.eclipse.xtext.generator.parser.antlr

import com.google.common.base.Stopwatch
import com.google.common.io.Files
import com.google.inject.Inject
import java.io.File
import java.nio.charset.Charset
import java.util.List
import java.util.concurrent.TimeUnit
import org.eclipse.xpand2.XpandExecutionContextImpl
import org.eclipse.xpand2.XpandFacade
import org.eclipse.xtend.lib.annotations.Accessors
import org.eclipse.xtext.Grammar
import org.eclipse.xtext.generator.Generator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.adapter.FragmentAdapter
import org.eclipse.xtext.util.internal.Log
import org.eclipse.xtext.xtext.FlattenedGrammarAccess
import org.eclipse.xtext.xtext.RuleFilter
import org.eclipse.xtext.xtext.RuleNames
import org.eclipse.xtext.xtext.generator.Issues
import org.eclipse.xtext.xtext.generator.parser.antlr.GrammarNaming
import org.eclipse.xtext.xtext.generator.parser.antlr.ContentAssistGrammarNaming

/**
 * Compares the ANTLR grammar generated by {@link 
 * org.eclipse.xtext.xtext.generator.parser.antlr.XtextAntlrGeneratorFragment2
 * XtextAntlrGeneratorFragment2} with that of {@link XtextAntlrGeneratorFragment}
 * by running its grammar generation in a temporary folder and calling {@link
 * GrammarComparator} to compare them.
 * 
 * @author Christian Schneider - Initial contribution and API
 * @since 2.9
 */
 @Log
class XtextAntlrGeneratorComparisonFragment extends FragmentAdapter {

	private static val ENCODING = 'ISO-8859-1'
	
	@Inject
	GrammarNaming productionNaming
	
	@Inject
	ContentAssistGrammarNaming contentAssistNaming
	
	@Inject
	AntlrGrammarComparator comparator

	@Accessors
	AntlrOptions options

	@Accessors
	boolean partialParsing;

	@Accessors
	boolean skipContentAssistGrammarComparison = false

	private List<String> advices = newArrayList()

	public def void addRegisterAdvice(String advice) {
		advices += advice;
	}

	static class ErrorHandler implements AntlrGrammarComparator.IErrorHandler {

		private File tmpFolder;

		new(File tmpFolder) {
			this.tmpFolder = tmpFolder
		}

		override handleInvalidGeneratedGrammarFile(AntlrGrammarComparator.ErrorContext context) {
			deleteDir(tmpFolder)
			
			throw new RuntimeException('''
				Noticed an unexpectect character sequence in file «context.testedGrammar.absoluteFileName
					» in/before line «context.testedGrammar.lineNumber».''')
		}
		
		override handleInvalidReferenceGrammarFile(AntlrGrammarComparator.ErrorContext context) {
			copyFile(context.referenceGrammar.absoluteFileName, context.testedGrammar.absoluteFileName)
			deleteDir(tmpFolder)
			
			throw new RuntimeException('''
				Noticed an unexpectect character sequence in file «context.referenceGrammar.absoluteFileName
					» in/before line «context.referenceGrammar.lineNumber».''')
		}
		
		override handleMismatch(String match, String matchReference, AntlrGrammarComparator.ErrorContext context) {
			copyFile(context.referenceGrammar.absoluteFileName, context.testedGrammar.absoluteFileName)
			deleteDir(tmpFolder)
			
			throw new RuntimeException('''
				Generated grammar «context.testedGrammar.absoluteFileName» differs at token «match» (line «
					context.testedGrammar.lineNumber»), expected token «matchReference» (line «context.referenceGrammar.lineNumber»).''')
		}
	}

	/** 
	 * Deactivate the super class' initialization check.
	 */
	override checkConfiguration(Issues issues) {
	}

	/**
	 * Tweaks the generation of the {@link Generator#SRC_GEN Generator.SRC_GEN} outlet
	 * and injects the {@link #getTmpPath()}.
	 */
	override protected createOutlet(boolean append, String encoding, String name, boolean overwrite, String path) {
		if (name == Generator.SRC_GEN || name == Generator.SRC_GEN_IDE || name == Generator.SRC_GEN_UI) {
			super.createOutlet(append, encoding, name, overwrite, getTmpFolder().absolutePath)			
		} else {			
			super.createOutlet(append, encoding, name, overwrite, path)
		}
	}

	override generate() {
		if (naming === null) {			
			naming = createNaming()
		}
		
		if (options === null) {			
			options = new AntlrOptions
		}
			
		val errorHandler = new ErrorHandler(tmpFolder)
			
		if (projectConfig.runtime?.srcGen != null) {
			projectConfig.runtime.srcGen.loadAndCompareGrammars(
				Generator.SRC_GEN, productionNaming.getParserGrammar(grammar).grammarFileName, errorHandler
			)
		}
		
		if (!skipContentAssistGrammarComparison && projectConfig.genericIde?.srcGen != null) {
			projectConfig.genericIde.srcGen.loadAndCompareGrammars(
				Generator.SRC_GEN_IDE, contentAssistNaming.getParserGrammar(grammar).grammarFileName, errorHandler
			)
		}
				
		deleteDir(tmpFolder)
	}


	protected def loadAndCompareGrammars(IFileSystemAccess2 fsa, String outlet, String grammarFileName, ErrorHandler errorHandler) {
		val stopWatch = Stopwatch.createStarted
		
		outlet.performXpandBasedGeneration()
		
		val absoluteGrammarFileNameReference = '''«tmpFolder.absolutePath»/«grammarFileName»'''
		
		val grammar = fsa.readTextFile(grammarFileName)
		val grammarReference = Files.toString(new File(absoluteGrammarFileNameReference), Charset.forName(ENCODING))
		
		val result = comparator.compareGrammars(grammar, grammarReference,
			'''«fsa.path»/«grammarFileName»''', absoluteGrammarFileNameReference, errorHandler
		)
		
		val time = stopWatch.elapsed(TimeUnit.MILLISECONDS)
		
		val type = if (outlet === Generator.SRC_GEN) "parser" else "content assist" 
		
		LOG.info('''Generated «type» grammar of «result.testedGrammar.lineNumber
				» lines matches expected one of «result.referenceGrammar.lineNumber» («time» ms).''')
	}


	def protected void performXpandBasedGeneration(String outlet) { 
		val RuleFilter filter = new RuleFilter();
		filter.setDiscardUnreachableRules(options.isSkipUnusedRules());
		
		val RuleNames ruleNames = RuleNames.getRuleNames(grammar, true);
		val Grammar flattened = new FlattenedGrammarAccess(ruleNames, filter).getFlattenedGrammar();
		
		val context = createExecutionContext() as XpandExecutionContextImpl;
		
		advices.forEach[
			context.registerAdvices(it);
		];
		
		if (outlet == Generator.SRC_GEN
					&& context.output.getOutlet(Generator.SRC_GEN) != null) {
			val template = XtextAntlrGeneratorFragment.getName().replaceAll("\\.", "::");
			XpandFacade.create(context).evaluate2(template + "::generate", flattened, #[ options ]);
		
		} else if (outlet == Generator.SRC_GEN_IDE
					&& context.output.getOutlet(Generator.SRC_GEN_IDE) != null) {
			val template = XtextAntlrUiGeneratorFragment.getName().replaceAll("\\.", "::");
			XpandFacade.create(context).evaluate2(template + "::generate", flattened, #[
				options, partialParsing, naming.hasIde
			]);
		}
	}


	/**
	 * offers a singleton temporary folder 
	 */
	private def File create path: Files.createTempDir() getTmpFolder() {
	}
	
	protected static def copyFile(String from, String to) {
		Files.copy(
			new File(from),
			new File('''«to.substring(0, to.length - 2)»Expected.g''')
		)
	}
	
	/** little helper for cleaning up the temporary stuff. */
    private static def void deleteDir(File dir) {
        if (!dir.exists) {
            return;
        }

        org.eclipse.xtext.util.Files.sweepFolder(dir)
    }
}
