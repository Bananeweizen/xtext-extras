«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»

«EXTENSION org::eclipse::xtext::grammargen::GrammarGen»
«EXTENSION org::eclipse::xtext::Extensions»
«EXTENSION org::eclipse::xtext::XtextUtil»

«DEFINE grammar FOR Grammar»
«FILE pathName()+'/parser/internal/Internal'+languageName()+'.g'»
grammar Internal«languageName()»;

options {
	superClass=AbstractAntlrParser;
}

@lexer::header {
package «packageName()».parser.internal;
}

@lexer::members {

  public Token nextToken() {
        while (true) {
            this.token = null;
            this.channel = Token.DEFAULT_CHANNEL;
            this.tokenStartCharIndex = input.index();
            this.tokenStartCharPositionInLine = input.getCharPositionInLine();
            this.tokenStartLine = input.getLine();
            this.text = null;
            if ( input.LA(1)==CharStream.EOF ) {
                return Token.EOF_TOKEN;
            }
            try {
                mTokens();
                if ( this.token==null ) {
                    emit();
                }
                else if ( this.token==Token.SKIP_TOKEN ) {
                    continue;
                }
                return this.token;
            }
            catch (RecognitionException re) {
                reportError(re);
                if ( re instanceof NoViableAltException ) { recover(re); }
                                // create token that holds mismatched char
                Token t = new CommonToken(input, Token.INVALID_TOKEN_TYPE,
                                          Token.HIDDEN_CHANNEL,
                                          this.tokenStartCharIndex,
                                          getCharIndex()-1);
                t.setLine(this.tokenStartLine);
                t.setCharPositionInLine(this.tokenStartCharPositionInLine);
                emit(t);
                return this.token;
            }
        }
    }
}

@parser::header {
package «packageName()».parser.internal; 

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.xtext.parsetree.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractAntlrParser;
}

@parser::members {
 
    public Internal«languageName()»Parser(TokenStream input, IElementFactory factory) {
        this(input);
        this.factory = factory;
		grammar = LanguageFacadeFactory.getFacade("«languageId()»").getGrammar();
    }
    
    protected void setLexerRule(LeafNode node, Token t) {
    /*    LexerRule lexerRule = «languageName()»TokenTypeResolver.getLexerRule(node, t.getType());
        if(lexerRule != null) {
            node.setGrammarElement(lexerRule);
        }*/
    }

}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
        IParseError error = createParseError(re);
        reportError(error, re);
    } 
}

internalParse returns [EObject current=null] :
	 { currentNode = «EXPAND createCompositeNode FOR parserRules.first()» }
	 iv_«parserRules.first().ruleName()»=«parserRules.first().ruleName()» 
	 { $current=$iv_«parserRules.first().ruleName()».current; } 
	 EOF 
;
«EXPAND rule(this) FOREACH parserRules»

«EXPAND rule(this) FOREACH allLexerRules()»

«ENDFILE»
«ENDDEFINE»

«DEFINE rule(Grammar g) FOR ParserRule»

// Rule «name»
«ruleName()» returns [EObject current=null] 
    @init { EObject temp=null; }:
    «EXPAND ebnf(g) FOR this.alternatives»;
«ENDDEFINE»

«DEFINE rule(Grammar g) FOR LexerRule»
«ruleName()» : «bodyWithoutQuotes()»;
«ENDDEFINE»

«DEFINE ebnf(Grammar g) FOR AbstractElement-»
«IF mustBeParenthesized()»(«EXPAND ebnf2(g)»)«ELSE»«EXPAND ebnf2(g)»«ENDIF»«cardinality-»
«ENDDEFINE»

«DEFINE ebnf2(Grammar g) FOR AbstractElement»ERROR «metaType.name» not matched«ENDDEFINE»

«DEFINE ebnf2(Grammar g) FOR Alternatives-»«EXPAND ebnf(g) FOREACH groups SEPARATOR '\n    |'»«ENDDEFINE»

«DEFINE ebnf2(Grammar g) FOR Group»«EXPAND ebnf(g) FOREACH abstractTokens»«ENDDEFINE»

«DEFINE ebnf2(Grammar g) FOR Assignment»
    «IF isParserRuleAssignment()»
    { 
        currentNode=«EXPAND createCompositeNode FOR terminal» 
    }
    «ENDIF-»
    «localVar()»=«EXPAND ebnf(g) FOR terminal» 
    {
        «IF isParserRuleAssignment()»currentNode = currentNode.getParent();
        «ENDIF-»
        if ($current==null) {
            $current = factory.create("«containingParserRule().getReturnTypeName()»");
            associateNodeWithAstElement(currentNode, $current);
        }
        factory.«setOrAdd()»($current, "«feature»", «IF isBoolean()»true«ELSE»«localVar()»«ENDIF»);«
        IF isKeywordAssignment()
            »        «
            EXPAND createLeafNode FOR terminal
            »«
        ENDIF
    »    }
«ENDDEFINE»

«DEFINE ebnf2(Grammar g) FOR Action»
    { 
        temp=factory.create("«theCurrentType(this,g).getQualifiedName()»");
        factory.«setOrAdd()»(temp, "«feature»",$current);
        $current = temp; 
        temp = null;
        «EXPAND insertCompositeNode» 
        associateNodeWithAstElement(currentNode, $current); 
    }
«ENDDEFINE»

«DEFINE ebnf2(Grammar g) FOR Keyword»'«withoutQuotes()»' 
«IF !isAssigned()»
    {
        «EXPAND createLeafNode» 
    }
«ENDIF»«ENDDEFINE»

«DEFINE ebnf2(Grammar g) FOR RuleCall-»
«IF ParserRule.isInstance(calledRule()) && !isAssigned()»«localVar()»=«ENDIF-»
«calledRule().ruleName()-»
«IF ParserRule.isInstance(calledRule()) && !isAssigned()»
    { 
        $current = $«localVar()».current; 
    }
«ENDIF-»
«IF LexerRule.isInstance(calledRule())»
    { 
    «EXPAND createLeafNode» 
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE createCompositeNode FOR emf::EObject
    »createCompositeNode("«
    getID()
    »" /* «
    this.metaType.name» */, currentNode);«
ENDDEFINE»

«DEFINE insertCompositeNode FOR Action
    »CompositeNode newNode = createCompositeNode("«
    getID()
    »" /* «
    this.metaType.name» */, currentNode.getParent());
    newNode.getChildren().add(currentNode);
    currentNode = newNode;«
ENDDEFINE»

«DEFINE createLeafNode FOR emf::EObject
    »createLeafNode("«
    getID()
    »" /* «
    this.metaType.name
    » */, currentNode,«
    IF isAssigned()
        »"«
        containingAssignment().feature
        »"«
    ELSE
        »null«
    ENDIF
    »);«
ENDDEFINE»

