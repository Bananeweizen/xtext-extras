«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»

«EXTENSION org::eclipse::xtext::grammargen::GrammarGen»
«EXTENSION org::eclipse::xtext::TypeResolution»

«DEFINE grammar FOR Grammar»
«FILE pathName()+'/parser/internal/Internal'+languageName()+'.g'»
grammar Internal«languageName()»;

@lexer::header {
package «packageName()».parser.internal;
}

@lexer::members {

  public Token nextToken() {
        while (true) {
            this.token = null;
            this.channel = Token.DEFAULT_CHANNEL;
            this.tokenStartCharIndex = input.index();
            this.tokenStartCharPositionInLine = input.getCharPositionInLine();
            this.tokenStartLine = input.getLine();
            this.text = null;
            if ( input.LA(1)==CharStream.EOF ) {
                return Token.EOF_TOKEN;
            }
            try {
                mTokens();
                if ( this.token==null ) {
                    emit();
                }
                else if ( this.token==Token.SKIP_TOKEN ) {
                    continue;
                }
                return this.token;
            }
            catch (RecognitionException re) {
                reportError(re);
                if ( re instanceof NoViableAltException ) { recover(re); }
                                // create token that holds mismatched char
                Token t = new CommonToken(input, Token.INVALID_TOKEN_TYPE,
                                          Token.HIDDEN_CHANNEL,
                                          this.tokenStartCharIndex,
                                          getCharIndex()-1);
                t.setLine(this.tokenStartLine);
                t.setCharPositionInLine(this.tokenStartCharPositionInLine);
                emit(t);
                return this.token;
            }
        }
    }
}

@parser::header {
package «packageName()».parser.internal; 

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.xtext.parsetree.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import «packageName()».parser.internal.«languageName()»TokenTypeResolver;
}

@parser::members {
    public TokenStream getInput() {
    	return input;
    }

    private IElementFactory factory;
    public Internal«languageName()»Parser(TokenStream input, IElementFactory factory) {
        this(input);
        this.factory = factory;
    }
    
    private List<IParseError> parseErrors;
    private IParseError createParseError(RecognitionException re) {
		LeafNode ln = null;
		if (currentNode!=null) {
		    CompositeNode root = (CompositeNode) EcoreUtil.getRootContainer(currentNode);
		    List<LeafNode> list = root.getLeafNodes();
		    if (list.size()>lastErrorIndex)
		        ln = list.get(lastErrorIndex);
		}
		IParseError error = null;
		if (ln == null) {
			CommonToken lt = (CommonToken) input.LT(input.index());
			error = new ParseError(lt.getLine(), lt.getStartIndex(), lt.getText() != null ? lt.getText()
					.length() : 0, lt.getText(), getErrorMessage(re, getTokenNames()), re);
		} else {
			error = new ParseError(ln, getErrorMessage(re, getTokenNames()), re);
		}
		parseErrors.add(error);
		return error;
	}
    
    protected void reportError(IParseError error, RecognitionException re) {
            reportError(re);
    }
            
            private int lastConsumedIndex = -1;
        
             private void appendAllTokens() {
                for (int x = lastConsumedIndex+1; input.size()>x;input.consume(),x++) {
                    Token hidden = input.get(x);
                    LeafNode leafNode = ParsetreeFactory.eINSTANCE.createLeafNode();
                    leafNode.setText(hidden.getText());
                    leafNode.setHidden(true);
                    setLexerRule(leafNode, hidden);
                    currentNode.getChildren().add(leafNode);
                }
            }

             public List<LeafNode> appendSkippedTokens() {
               	List<LeafNode> skipped = new ArrayList<LeafNode>();
                Token currentToken = input.LT(-1);
                int currentTokenIndex = (currentToken == null) ? -1 : currentToken.getTokenIndex();
                Token tokenBefore = (lastConsumedIndex == -1) ? null :input.get(lastConsumedIndex);
                int indexOfTokenBefore = tokenBefore!=null?tokenBefore.getTokenIndex() : -1;
                if (indexOfTokenBefore+1<currentTokenIndex) {
                    for (int x = indexOfTokenBefore+1; x<currentTokenIndex;x++) {
                        Token hidden = input.get(x);
                        LeafNode leafNode = ParsetreeFactory.eINSTANCE.createLeafNode();
                        leafNode.setText(hidden.getText());
                        leafNode.setHidden(true);
                        setLexerRule(leafNode, hidden);
                        currentNode.getChildren().add(leafNode);
                        skipped.add(leafNode);
                    }
                }
                if(lastConsumedIndex < currentTokenIndex) {
                    LeafNode leafNode = ParsetreeFactory.eINSTANCE.createLeafNode();
                    leafNode.setText(currentToken.getText());
                    leafNode.setHidden(true);
                    setLexerRule(leafNode, currentToken);
                    currentNode.getChildren().add(leafNode);
                    skipped.add(leafNode);
                    lastConsumedIndex = currentToken.getTokenIndex();
                }
                return skipped;
            }
            
            public CompositeNode createCompositeNode(String grammarElementID, CompositeNode parentNode) {
                CompositeNode compositeNode = ParsetreeFactory.eINSTANCE.createCompositeNode();
                if (parentNode!=null) parentNode.getChildren().add(compositeNode);
                compositeNode.setGrammarElement(grammar.eResource().getEObject(grammarElementID));
                return compositeNode;
            }
            

            public Object createLeafNode(String grammarElementID, CompositeNode parentNode, String feature) {
                Token token = input.LT(-1);
                int indexOfTokenBefore = lastConsumedIndex;
                if (indexOfTokenBefore+1<token.getTokenIndex()) {
                    for (int x = indexOfTokenBefore+1; x<token.getTokenIndex();x++) {
                        Token hidden = input.get(x);
                        LeafNode leafNode = ParsetreeFactory.eINSTANCE.createLeafNode();
                        leafNode.setText(hidden.getText());
                        leafNode.setHidden(true);
                        setLexerRule(leafNode, hidden);
                        parentNode.getChildren().add(leafNode);
                    }
                }
                LeafNode leafNode = ParsetreeFactory.eINSTANCE.createLeafNode();
                leafNode.setText(token.getText());
                leafNode.setGrammarElement(grammar.eResource().getEObject(grammarElementID));
                leafNode.setFeature(feature);
                parentNode.getChildren().add(leafNode);
                lastConsumedIndex = token.getTokenIndex();
                return leafNode;
            }

            private void appendTrailingHiddenTokens(CompositeNode parentNode) {
                Token tokenBefore = input.LT(-1);
                int size = input.size();
                if (tokenBefore!=null && tokenBefore.getTokenIndex()<size) {
                    for (int x = tokenBefore.getTokenIndex()+1; x<size;x++) {
                        Token hidden = input.get(x);
                        LeafNode leafNode = ParsetreeFactory.eINSTANCE.createLeafNode();
                        leafNode.setText(hidden.getText());
                        leafNode.setHidden(true);
                        setLexerRule(leafNode, hidden);
                        parentNode.getChildren().add(leafNode);
                        lastConsumedIndex = hidden.getTokenIndex();
                    }
                }
            }
            
            public void associateNodeWithAstElement(CompositeNode node, EObject astElement) {
                if(node.getElement() != null && node.getElement() != astElement) {
                    throw new ParseException(new ParseError(node, "Reassignment of astElement in parse tree node", null));
                }
                node.setElement(astElement);
                if(astElement instanceof EObject) {
                    EObject eObject = (EObject) astElement;
                    NodeAdapter adapter = (NodeAdapter) NodeAdapterFactory.INSTANCE.adapt(eObject, AbstractNode.class);
                    adapter.setParserNode(node); 
                }
            }
            
    protected void setLexerRule(LeafNode node, Token t) {
        LexerRule lexerRule = «languageName()»TokenTypeResolver.getLexerRule(node, t.getType());
        if(lexerRule != null) {
            node.setGrammarElement(lexerRule);
        }
    }
    
    private CompositeNode currentNode;
    public CompositeNode getCurrentNode() {
        return currentNode;
    }
    
    private org.eclipse.xtext.Grammar grammar = LanguageFacadeFactory.getFacade("«languageId()»").getGrammar();;

}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
        IParseError error = createParseError(re);
        reportError(error, re);
    } 
}

parse returns [IParseResult result] 
	@init { EObject current = null; parseErrors = new ArrayList<IParseError>();} : 
    { currentNode = «EXPAND createCompositeNode FOR parserRules.first()» }
    «parserRules.first().ruleName()» 
    { current=$«parserRules.first().ruleName()».current; }
    EOF 
    { appendTrailingHiddenTokens(currentNode); };
    finally { appendAllTokens(); $result = new ParseResult(current, currentNode,parseErrors); }

«EXPAND rule FOREACH parserRules»

«EXPAND rule FOREACH allLexerRules()»

«ENDFILE»
«ENDDEFINE»

«DEFINE rule FOR ParserRule»

// Rule «name»
«ruleName()» returns [EObject current=null] 
    @init { EObject temp=null; }:
    «EXPAND ebnf FOR this.alternatives»;
«ENDDEFINE»

«DEFINE rule FOR LexerRule»
«ruleName()» : «bodyWithoutQuotes()»;
«ENDDEFINE»

«DEFINE ebnf FOR AbstractElement-»
«IF mustBeParenthesized()»(«EXPAND ebnf2»)«ELSE»«EXPAND ebnf2»«ENDIF»«cardinality-»
«ENDDEFINE»

«DEFINE ebnf2 FOR AbstractElement»ERROR «metaType.name» not matched«ENDDEFINE»

«DEFINE ebnf2 FOR Alternatives-»«EXPAND ebnf FOREACH groups SEPARATOR '\n    |'»«ENDDEFINE»

«DEFINE ebnf2 FOR Group»«EXPAND ebnf FOREACH abstractTokens»«ENDDEFINE»

«DEFINE ebnf2 FOR Assignment»
    «IF isParserRuleAssignment()»
    { 
        currentNode=«EXPAND createCompositeNode FOR terminal» 
    }
    «ENDIF-»
    «localVar()»=«EXPAND ebnf FOR terminal» 
    {
        «IF isParserRuleAssignment()»currentNode = currentNode.getParent();
        «ENDIF-»
        if ($current==null) {
            $current = factory.create("«containingParserRule().getReturnTypeName()»");
            associateNodeWithAstElement(currentNode, $current);
        }
        factory.«setOrAdd()»($current, "«feature»", «IF isBoolean()»true«ELSE»«localVar()»«ENDIF»);«
        IF isKeywordAssignment()
            »        «
            EXPAND createLeafNode FOR terminal
            »«
        ENDIF
    »    }
«ENDDEFINE»

«DEFINE ebnf2 FOR Action»
    { 
        temp=factory.create("«currentType().qualifiedName()»");
        factory.«setOrAdd()»(temp, "«feature»",$current);
        $current = temp; 
        temp = null;
        «EXPAND insertCompositeNode» 
        associateNodeWithAstElement(currentNode, $current); 
    }
«ENDDEFINE»

«DEFINE ebnf2 FOR Keyword»'«withoutQuotes()»' 
«IF !isAssigned()»
    {
        «EXPAND createLeafNode» 
    }
«ENDIF»«ENDDEFINE»

«DEFINE ebnf2 FOR RuleCall-»
«IF ParserRule.isInstance(calledRule()) && !isAssigned()»«localVar()»=«ENDIF-»
«calledRule().ruleName()-»
«IF ParserRule.isInstance(calledRule()) && !isAssigned()»
    { 
        $current = $«localVar()».current; 
    }
«ENDIF-»
«IF LexerRule.isInstance(calledRule())»
    { 
    «EXPAND createLeafNode» 
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE createCompositeNode FOR emf::EObject
    »createCompositeNode("«
    getID()
    »" /* «
    this.metaType.name» */, currentNode);«
ENDDEFINE»

«DEFINE insertCompositeNode FOR Action
    »CompositeNode newNode = createCompositeNode("«
    getID()
    »" /* «
    this.metaType.name» */, currentNode.getParent());
    newNode.getChildren().add(currentNode);
    currentNode = newNode;«
ENDDEFINE»

«DEFINE createLeafNode FOR emf::EObject
    »createLeafNode("«
    getID()
    »" /* «
    this.metaType.name
    » */, currentNode,«
    IF isAssigned()
        »"«
        containingAssignment().feature
        »"«
    ELSE
        »null«
    ENDIF
    »);«
ENDDEFINE»

