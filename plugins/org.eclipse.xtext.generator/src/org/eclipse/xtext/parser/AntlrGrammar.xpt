«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»
«IMPORT xtextgen»

«EXTENSION org::eclipse::xtext::parser::AntlrGrammar»
«EXTENSION org::eclipse::xtext::Extensions»
«EXTENSION org::eclipse::xtext::XtextUtil»
«EXTENSION org::eclipse::xtext::parser::Parser»

«DEFINE grammar FOR GenService»
«FILE internalAntlrGrammarFullPath()»
/*
«fileHeader()»
*/
grammar «internalAntlrGrammarName()»;

options {
	superClass=AbstractAntlrParser;
}

@lexer::header {
package «internalPackage()»;
}

@lexer::members {

  public Token nextToken() {
        while (true) {
            this.token = null;
            this.channel = Token.DEFAULT_CHANNEL;
            this.tokenStartCharIndex = input.index();
            this.tokenStartCharPositionInLine = input.getCharPositionInLine();
            this.tokenStartLine = input.getLine();
            this.text = null;
            if ( input.LA(1)==CharStream.EOF ) {
                return Token.EOF_TOKEN;
            }
            try {
                mTokens();
                if ( this.token==null ) {
                    emit();
                }
                else if ( this.token==Token.SKIP_TOKEN ) {
                    continue;
                }
                return this.token;
            }
            catch (RecognitionException re) {
                reportError(re);
                if ( re instanceof NoViableAltException ) { recover(re); }
                                // create token that holds mismatched char
                Token t = new CommonToken(input, Token.INVALID_TOKEN_TYPE,
                                          Token.HIDDEN_CHANNEL,
                                          this.tokenStartCharIndex,
                                          getCharIndex()-1);
                t.setLine(this.tokenStartLine);
                t.setCharPositionInLine(this.tokenStartCharPositionInLine);
                emit(t);
                return this.token;
            }
        }
    }
}

@parser::header {
package «internalPackage()»; 

import java.io.InputStream;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.xtext.parsetree.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
}

@parser::members {
 
    public «internalParserClassName()»(TokenStream input, IAstFactory factory, Grammar g) {
        this(input);
        this.factory = factory;
		grammar = g;
    }
    
    @Override
    protected InputStream getTokenFile() {
    	ClassLoader classLoader = «internalParserClassName()».class.getClassLoader();
    	return classLoader.getResourceAsStream("«internalPackageFullPath()»/«internalAntlrGrammarName()».tokens");
    }
    
    @Override
    protected String getFirstRuleName() {
    	return "«grammar().parserRules.first().name»";	
   	} 
}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
    } 
}
«EXPAND antlrRules FOR grammar()»
«ENDFILE»
«ENDDEFINE»

«DEFINE antlrRules FOR Grammar»
«EXPAND rule FOREACH allParserRules()»

«EXPAND rule FOREACH allLexerRules()»
«ENDDEFINE»


«DEFINE rule FOR ParserRule»
«IF isCalled()»
// Entry rule «entryRuleName()»
«entryRuleName()» returns [EObject current=null] :
	{ currentNode = «EXPAND createCompositeNode» }
	 iv_«ruleName()»=«ruleName()» 
	 { $current=$iv_«ruleName()».current; } 
	 EOF 
;

// Rule «name»
«ruleName()» returns [EObject current=null] 
    @init { EObject temp=null; setCurrentLookahead(); resetLookahead(); }
    @after { resetLookahead(); }:
    «EXPAND ebnf FOR this.alternatives»;
    «ENDIF»
«ENDDEFINE»

«DEFINE rule FOR LexerRule»
«ruleName()» : «body»;
«ENDDEFINE»

«DEFINE ebnf FOR AbstractElement-»
«IF mustBeParenthesized()»(«EXPAND ebnf2»)«ELSE»«EXPAND ebnf2»«ENDIF»«cardinality-»
«ENDDEFINE»

«DEFINE ebnf2 FOR AbstractElement»ERROR «metaType.name» not matched«ENDDEFINE»

«DEFINE ebnf2 FOR Alternatives-»«EXPAND ebnf FOREACH groups SEPARATOR '\n    |'»«ENDDEFINE»

«DEFINE ebnf2 FOR Group»«EXPAND ebnf FOREACH abstractTokens»«ENDDEFINE»

«DEFINE ebnf2 FOR Assignment»
    «IF isParserRuleAssignment()»
    { 
        currentNode=«EXPAND createCompositeNode FOR terminal» 
    }
    «ENDIF-»
    «localVar()»=«EXPAND ebnf FOR terminal» 
    {
        «IF isParserRuleAssignment()»currentNode = currentNode.getParent();
        «ENDIF-»
        if ($current==null) {
            $current = factory.create("«containingParserRule().getReturnTypeName()»");
            associateNodeWithAstElement(currentNode, $current);
        }
        factory.«setOrAdd()»($current, "«feature»", «IF isBoolean()»true«ELSE»«localVar()»«ENDIF»,«terminal.toStringLiteral()»);«
        IF isKeywordAssignment()
            »        «
            EXPAND createLeafNode FOR terminal
            »«
        ENDIF
    »    }
«ENDDEFINE»

«DEFINE ebnf2 FOR Action»
    { 
        temp=factory.create("«theCurrentType(this).getQualifiedName()»");
        factory.«setOrAdd()»(temp, "«feature»",$current);
        $current = temp; 
        temp = null;
        «EXPAND insertCompositeNode» 
        associateNodeWithAstElement(currentNode, $current); 
    }
«ENDDEFINE»

«DEFINE ebnf2 FOR Keyword»'«value»' 
«IF !isAssigned()»
    {
        «EXPAND createLeafNode» 
    }
«ENDIF»«ENDDEFINE»

«DEFINE ebnf2 FOR RuleCall-»
«IF ParserRule.isInstance(calledRule()) && !isAssigned()»
    { 
        currentNode=«EXPAND createCompositeNode» 
    }
    «localVar()»=«ENDIF-»
«calledRule().ruleName()-»
«IF ParserRule.isInstance(calledRule()) && !isAssigned()»
    { 
        $current = $«localVar()».current; 
        currentNode = currentNode.getParent();
    }
«ENDIF-»
«IF LexerRule.isInstance(calledRule())»
    { 
    «EXPAND createLeafNode» 
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE createCompositeNode FOR emf::EObject
    »createCompositeNode("«
    objectURI()
    »" /* «
    this.metaType.name» */, currentNode);«
ENDDEFINE»

«DEFINE insertCompositeNode FOR Action
    »CompositeNode newNode = createCompositeNode("«
    objectURI()
    »" /* «
    this.metaType.name» */, currentNode.getParent());
    newNode.getChildren().add(currentNode);
    moveLookaheadInfo(currentNode, newNode);
    currentNode = newNode;«
ENDDEFINE»

«DEFINE createLeafNode FOR emf::EObject
    »createLeafNode("«
    objectURI()
    »" /* «
    this.metaType.name
    » */, currentNode,«
    IF isAssigned()
        »"«
        containingAssignment().feature
        »"«
    ELSE
        »null«
    ENDIF
    »);«
ENDDEFINE»

