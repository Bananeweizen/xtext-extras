«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»
«IMPORT xtextgen»

«EXTENSION org::eclipse::xtext::parser::AntlrGrammar»
«EXTENSION org::eclipse::xtext::Extensions»
«EXTENSION org::eclipse::xtext::XtextUtil»
«EXTENSION org::eclipse::xtext::parser::Parser»

«DEFINE grammar FOR GenService»
«FILE internalAntlrGrammarFullPath()»
/*
«fileHeader()»
*/
grammar «internalAntlrGrammarName()»;

options {
	superClass=AbstractAntlrParser;
}

@lexer::header {
package «internalPackage()»;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package «internalPackage()»; 

import java.io.InputStream;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.xtext.parsetree.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
}

@parser::members {
 
    public «internalParserClassName()»(TokenStream input, IAstFactory factory, Grammar g) {
        this(input);
        this.factory = factory;
		grammar = g;
    }
    
    @Override
    protected InputStream getTokenFile() {
    	ClassLoader classLoader = «internalParserClassName()».class.getClassLoader();
    	return classLoader.getResourceAsStream("«internalPackageFullPath()»/«internalAntlrGrammarName()».tokens");
    }
    
    @Override
    protected String getFirstRuleName() {
    	return "«grammar().allParserRules().first().name»";	
   	} 
}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
    } 
}
«EXPAND antlrRules FOR grammar()»
«ENDFILE»
«ENDDEFINE»

«DEFINE antlrRules FOR Grammar»
«EXPAND rule FOREACH allParserRules()»

«EXPAND rule FOREACH allLexerRules()»
«ENDDEFINE»


«DEFINE rule FOR ParserRule»
«IF isCalled()»
// Entry rule «entryRuleName()»
«entryRuleName()» returns [EObject current=null] :
	{ currentNode = «EXPAND createCompositeNode» }
	 iv_«ruleName()»=«ruleName()» 
	 { $current=$iv_«ruleName()».current; } 
	 EOF 
;

// Rule «name»
«ruleName()» returns [EObject current=null] 
    @init { EObject temp=null; setCurrentLookahead(); resetLookahead(); }
    @after { resetLookahead(); }:
    «EXPAND ebnf FOR this.alternatives»;
    «ENDIF»
«ENDDEFINE»

«DEFINE rule FOR LexerRule»
«ruleName()» : «body»;
«ENDDEFINE»

«DEFINE ebnf FOR AbstractElement-»
«IF mustBeParenthesized()»(«EXPAND ebnf2»)«ELSE»«EXPAND ebnf2»«ENDIF»«cardinality-»
«ENDDEFINE»

«DEFINE ebnf2 FOR AbstractElement»ERROR «metaType.name» not matched«ENDDEFINE»

«DEFINE ebnf2 FOR Alternatives-»«EXPAND ebnf FOREACH groups SEPARATOR '\n    |'»«ENDDEFINE»

«DEFINE ebnf2 FOR Group»«EXPAND ebnf FOREACH abstractTokens»«ENDDEFINE»

«DEFINE ebnf2 FOR Assignment»	
	«IF !eAllContents.typeSelect(CrossReference).isEmpty»
		«REM» Cross references are handled in the linking phase «ENDREM»
		«EXPAND ebnf FOR terminal» 
	«ELSE»
	    «IF isParserRuleAssignment()»
	    { 
	        currentNode=«EXPAND createCompositeNode FOR terminal» 
	    }
	    «ENDIF-»
	    «localVar()»=«EXPAND ebnf FOR terminal» 
	    {
	        «IF isParserRuleAssignment()»currentNode = currentNode.getParent();
	        «ENDIF-»
	        if ($current==null) {
	            $current = factory.create("«containingParserRule().getReturnTypeName()»");
	            associateNodeWithAstElement(currentNode, $current);
	        }
	        «REM»the use of input.LT(-1) in the following line is a workaroudn for a bug of antlr, where assignements of alternative keywords are ignored when there are actions«ENDREM»
	        factory.«setOrAdd()»($current, "«feature»", «
	        	IF isBoolean()»true«
	        	ELSE»«eAllContents.typeSelect(Keyword).isEmpty ? localVar() : "input.LT(-1)"»«
	        	ENDIF»,«terminal.toStringLiteral()»);
	         }
	«ENDIF»
«ENDDEFINE»

«DEFINE ebnf2 FOR CrossReference»
	«calledLexerRule().ruleName()-»
    { 
    «EXPAND createLeafNode» 
    }
«ENDDEFINE»

«DEFINE ebnf2 FOR Action»
    { 
        temp=factory.create("«theCurrentType(this).getQualifiedName()»");
        factory.«setOrAdd()»(temp, "«feature»",$current);
        $current = temp; 
        temp = null;
        «EXPAND insertCompositeNode» 
        associateNodeWithAstElement(currentNode, $current); 
    }
«ENDDEFINE»

«DEFINE ebnf2 FOR Keyword»'«value»' 
    {
        «EXPAND createLeafNode» 
    }
«ENDDEFINE»

«DEFINE ebnf2 FOR RuleCall-»
«IF ParserRule.isInstance(calledRule()) && !isAssigned()»
    { 
        currentNode=«EXPAND createCompositeNode» 
    }
    «localVar()»=«ENDIF-»
«calledRule().ruleName()-»
«IF ParserRule.isInstance(calledRule()) && !isAssigned()»
    { 
        $current = $«localVar()».current; 
        currentNode = currentNode.getParent();
    }
«ENDIF-»
«IF LexerRule.isInstance(calledRule())»
    { 
    «EXPAND createLeafNode» 
    }
«ENDIF-»
«ENDDEFINE»

«DEFINE createCompositeNode FOR emf::EObject
    »createCompositeNode("«
    objectURI()
    »" /* «
    this.metaType.name» */, currentNode);«
ENDDEFINE»

«DEFINE insertCompositeNode FOR Action
    »CompositeNode newNode = createCompositeNode("«
    objectURI()
    »" /* «
    this.metaType.name» */, currentNode.getParent());
    newNode.getChildren().add(currentNode);
    moveLookaheadInfo(currentNode, newNode);
    currentNode = newNode;«
ENDDEFINE»

«DEFINE createLeafNode FOR emf::EObject
    »createLeafNode("«
    objectURI()
    »" /* «
    this.metaType.name
    » */, «
    IF isAssigned()
        »"«
        containingAssignment().feature
        »"«
    ELSE
        »null«
    ENDIF
    »);«
ENDDEFINE»

