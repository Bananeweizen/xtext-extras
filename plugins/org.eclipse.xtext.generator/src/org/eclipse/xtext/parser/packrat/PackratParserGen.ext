/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
import xtext;
import xtextgen;
import predicate;
import emf;
import oaw;

extension org::eclipse::xtext::Properties reexport;
extension org::eclipse::xtext::Extensions reexport;
extension org::eclipse::xtext::GrammarUtil reexport;
extension org::eclipse::xtend::util::stdlib::io;

String consumeMethodName(AbstractElement this):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.getConsumeMethodName(org.eclipse.xtext.AbstractElement);

String delimiterFieldName(AbstractElement this):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.getDelimiterFieldName(org.eclipse.xtext.AbstractElement);

String globalDelimiterFieldName(AbstractElement this):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.getGlobalDelimiterFieldName(org.eclipse.xtext.AbstractElement);
			
String consumerClassName(AbstractRule this):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.getConsumerClassName(org.eclipse.xtext.AbstractRule);
	
String consumerFieldName(AbstractRule this):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.getConsumerFieldName(org.eclipse.xtext.AbstractRule);

String consumerSetterName(AbstractRule this):
	"set" + consumerFieldName().toFirstUpper();
	
String consumerGetterName(AbstractRule this):
	"get" + consumerFieldName().toFirstUpper();
	
String consumerPackageName(AbstractRule this):
	grammar().getNamespace() + ".parser.packrat.consumers";	

String fullConsumerClassName(AbstractRule this):
    consumerPackageName() + "." + consumerClassName();
    
String grammarAccess(Grammar this):
    JAVA org.eclipse.xtext.grammaraccess.GrammarAccessUtil.getGrammarAccessFQName(org.eclipse.xtext.Grammar);
   
/* boolean canBeFollowedByIdentifier(Keyword this):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.canBeFollowedByIdentifier(org.eclipse.xtext.Keyword); */

List[Keyword] conflictingKeywords(AbstractElement this, Grammar grammar):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.getConflictingKeywords(org.eclipse.xtext.AbstractElement, org.eclipse.xtext.Grammar);

List[LexerRule] conflictingLexerRules(Keyword this, Grammar grammar):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.getConflictingLexerRules(org.eclipse.xtext.Keyword, org.eclipse.xtext.Grammar);

AbstractElement sameConflicts(AbstractElement this, Grammar grammar):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.findFirstWithSameConflicts(org.eclipse.xtext.AbstractElement, org.eclipse.xtext.Grammar);

Keyword sameConflicts(Keyword this, Grammar grammar):
	JAVA org.eclipse.xtext.parser.packrat.PackratParserGenUtil.findFirstKeywordWithSameConflicts(org.eclipse.xtext.Keyword, org.eclipse.xtext.Grammar);
		
boolean isPlus(AbstractElement this):
	!isOptional() && isMultipleCardinality();

boolean isStar(AbstractElement this):
	isOptional() && isMultipleCardinality();
	
boolean isQuestionMark(AbstractElement this):
	isOptional() && !isMultipleCardinality();
	
List[AbstractElement] allDelimited(AbstractRule this):
	containedRuleCalls().select(e|e.rule.metaType==LexerRule).
		union(eAllContents.typeSelect(Keyword)).
		union(eAllContents.typeSelect(CrossReference).select(e|e.rule.metaType==LexerRule))
	.toSet();
	