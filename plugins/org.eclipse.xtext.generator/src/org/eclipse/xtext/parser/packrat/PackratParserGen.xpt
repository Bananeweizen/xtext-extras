«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»
«IMPORT xtextgen»

«EXTENSION org::eclipse::xtext::Extensions»
«EXTENSION org::eclipse::xtext::Properties»
«EXTENSION org::eclipse::xtext::parser::packrat::PackratParserGen»

«DEFINE root FOR GenService»
	«EXPAND NonTerminalConsumer::root»
	«EXPAND TerminalConsumer::root»
	«EXPAND parser»
	«EXPAND parserConfiguration»
	«EXPAND delimiters»
«ENDDEFINE»

«DEFINE parser FOR GenService»
«FILE genClassFQName.toJavaFilePath() SRC_GEN-»
/*
«fileHeader()»
*/
package «genClassFQName.toJavaPackage()»;

import org.eclipse.xtext.parser.packrat.AbstractPackratParser;
import org.eclipse.xtext.parser.packrat.AbstractParserConfiguration.IInternalParserConfiguration;

public class «genClassFQName.toSimpleName()» extends AbstractPackratParser {

	@Override
	protected «languageName().toFirstUpper()»ParserConfiguration createParserConfiguration(IInternalParserConfiguration configuration) {
		return new «languageName().toFirstUpper()»ParserConfiguration(configuration);
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE parserConfiguration FOR GenService»
«FILE (genClassFQName.toJavaPackage() + "." + languageName() + "ParserConfiguration").toJavaFilePath() SRC_GEN-»
/*
«fileHeader()»
*/
package «genClassFQName.toJavaPackage()»;

import org.eclipse.xtext.parser.packrat.AbstractParserConfiguration;
import org.eclipse.xtext.parser.packrat.consumers.ITerminalConsumer;

«LET grammar().getSuperGrammar() AS superGrammar-»
«IF superGrammar != null-»
import «superGrammar.getNamespace()».parser.packrat.«superGrammar.getName().toFirstUpper().replaceAll("\\s","_")»ParserConfiguration; 

«ENDIF-»
«ENDLET-»
«FOREACH grammar().allRules() AS rule-»
import «rule.grammar().getNamespace()».parser.packrat.consumers.«rule.consumerClassName()»;
«ENDFOREACH-»

@SuppressWarnings("unused")
public class «languageName().toFirstUpper()»ParserConfiguration extends AbstractParserConfiguration {

«LET grammar().getSuperGrammar() AS superGrammar-»
«IF superGrammar != null-»
	private «superGrammar.getName().replaceAll("\\s","_").toFirstUpper()»ParserConfiguration «superGrammar.getName().replaceAll("\\s","_").toFirstLower()»Configuration; 

«ENDIF-»
«ENDLET-»
«FOREACH grammar().rules AS rule-»
    private «rule.consumerClassName()» «rule.consumerFieldName()»;
«ENDFOREACH-»

	public «languageName().toFirstUpper()»ParserConfiguration(IInternalParserConfiguration configuration) {
		super(configuration);
«LET grammar().getSuperGrammar() AS superGrammar-»
«IF superGrammar != null-»
		this.«superGrammar.getName().replaceAll("\\s","_").toFirstLower()»Configuration = new «superGrammar.getName().replaceAll("\\s","_").toFirstUpper()»ParserConfiguration(configuration);
«ENDIF-»
«ENDLET-»
	}

	public «grammar().allParserRules().first().consumerClassName()» getRootConsumer() {
		return «grammar().allParserRules().first().consumerFieldName()»;
	} 
	
	public void createNonTerminalConsumers() {
«LET grammar().getSuperGrammar() AS superGrammar-»
«IF superGrammar != null-»
		get«superGrammar.getName().replaceAll("\\s","_").toFirstUpper()»Configuration().createNonTerminalConsumers();
«ENDIF-»
«ENDLET-»
«FOREACH grammar().rules.typeSelect(ParserRule).select(e|!e.terminal) AS rule-»
		«rule.consumerFieldName()» = new «rule.consumerClassName()»(
«IF rule.definesHiddenTokens-»
    		this, new ITerminalConsumer[]{ «FOREACH rule.hiddenTokens AS hidden SEPARATOR ", "»«hidden.consumerGetterName()»()«ENDFOREACH-» }
«ELSE-»
    		this, null
«ENDIF-»
    	);
«ENDFOREACH-»
	}
	
	public void createTerminalConsumers() {
«LET grammar().getSuperGrammar() AS superGrammar-»
«IF superGrammar != null-»
		get«superGrammar.getName().replaceAll("\\s","_").toFirstUpper()»Configuration().createTerminalConsumers();
«ENDIF-»
«ENDLET-»
«FOREACH grammar().rules.typeSelect(ParserRule).select(e|e.terminal) AS rule-»
		«rule.consumerFieldName()» = new «rule.consumerClassName()»(this);
«ENDFOREACH-»
«FOREACH grammar().rules.typeSelect(LexerRule) AS rule-»
		«rule.consumerFieldName()» = new «rule.consumerClassName()»(this);
«ENDFOREACH-»
	}
	
	public void configureConsumers() {
«FOREACH grammar().allParserRules() AS rule-»
«LET rule.allCalledRules() AS calledRules-»
«IF !calledRules.isEmpty-»
«FOREACH calledRules AS calledRule-»
«IF rule.consumerGetterName() != "getRootConsumer"-»
«IF calledRule.consumerGetterName() != "getRootConsumer"-»
		«rule.consumerGetterName()»().«calledRule.consumerSetterName()»(«calledRule.consumerGetterName()»());
«ELSE-»
		«rule.consumerGetterName()»().«calledRule.consumerSetterName()»(getRootConsumer$());
«ENDIF-»
«ELSE-»
«IF calledRule.consumerGetterName() != "getRootConsumer"-»
		getRootConsumer$().«calledRule.consumerSetterName()»(«calledRule.consumerGetterName()»());
«ELSE-»
		getRootConsumer$().«calledRule.consumerSetterName()»(getRootConsumer$());
«ENDIF-»
«ENDIF-»
«ENDFOREACH-»

«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
«EXPAND setDelimiters(grammar()) FOREACH grammar().allParserRules().select(e|!e.terminal)-»
	}
	
«LET grammar().getSuperGrammar() AS superGrammar-»
«IF superGrammar != null-»
	// TODO collect superGrammars transitive
	public «superGrammar.getName().replaceAll("\\s","_").toFirstUpper()»ParserConfiguration get«superGrammar.getName().replaceAll("\\s","_").toFirstUpper()»Configuration() {
		return «superGrammar.getName().replaceAll("\\s","_").toFirstLower()»Configuration;
	} 
	
«ENDIF-»
«FOREACH grammar().allRules() AS rule-»
«IF rule.grammar() == grammar()-»
«IF rule.consumerGetterName() != "getRootConsumer"-»
    public «rule.consumerClassName()» «rule.consumerGetterName()»() {
    	return «rule.consumerFieldName()»;
    }
«ELSE-»
	public «rule.consumerClassName()» getRootConsumer$() {
    	return «rule.consumerFieldName()»;
    }
«ENDIF-»
«ELSE-»
«IF rule.consumerGetterName() != "getRootConsumer"-»
    public «rule.consumerClassName()» «rule.consumerGetterName()»() {
    	return get«superGrammar.getName().replaceAll("\\s","_").toFirstUpper()»Configuration().«rule.consumerGetterName()»();
    }
«ELSE-»
	public «rule.consumerClassName()» getRootConsumer$() {
    	return get«superGrammar.getName().replaceAll("\\s","_").toFirstUpper()»Configuration().getRootConsumer$();
    }
«ENDIF-»
«ENDIF-»

«ENDFOREACH-»
«ENDLET-»

}
«ENDFILE»
«ENDDEFINE»

«DEFINE setDelimiters(Grammar grammar) FOR ParserRule-»
«EXPAND setDelimiters(this, grammar) FOREACH allDelimited()-»
«ENDDEFINE»

«DEFINE setDelimiters(ParserRule rule, Grammar grammar) FOR AbstractElement-»
		«rule.consumerGetterName()»().set«delimiterFieldName().toFirstUpper()»(«languageName()»Delimiters.«sameConflicts(grammar).globalDelimiterFieldName()»);
«ENDDEFINE»

«DEFINE delimiters FOR GenService»
«FILE (genClassFQName.toJavaPackage() + "." + languageName() + "Delimiters").toJavaFilePath() SRC_GEN-»
/*
«fileHeader()»
*/
package «genClassFQName.toJavaPackage()»;

import org.eclipse.xtext.parser.packrat.matching.ICharacterClass;
import org.eclipse.xtext.parser.packrat.matching.ISequenceMatcher;
import org.eclipse.xtext.parser.packrat.matching.SetBasedKeywordMatcher;

public final class «languageName()»Delimiters {

	private «languageName()»Delimiters() {
		throw new UnsupportedOperationException("Utility classes may not be initialized");
	}
	
«EXPAND createDelimiters(grammar()) FOREACH grammar().allParserRules().select(e|!e.terminal).allDelimited()-»
}
«ENDFILE»
«ENDDEFINE»

«DEFINE createDelimiters(Grammar grammar) FOR AbstractElement-»
«ERROR "createDelimiters for " + metaType.name»
«ENDDEFINE»

«DEFINE createDelimitersImpl(Grammar grammar, AbstractRule rule) FOR AbstractElement-»
«LET sameConflicts(grammar) AS first-»
«IF first == this-»
«LET conflictingKeywords(grammar) AS conflicting-»
«IF !conflicting.isEmpty-»
	public static ISequenceMatcher «globalDelimiterFieldName()» = new SetBasedKeywordMatcher(
		«FOREACH conflicting AS c SEPARATOR ", "»"«c»"«ENDFOREACH»);
«ELSE-»
	public static ISequenceMatcher «globalDelimiterFieldName()» = ISequenceMatcher.Factory.nullMatcher();
«ENDIF-»

«ENDLET-»
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«DEFINE createDelimiters(Grammar grammar) FOR CrossReference-»
«EXPAND createDelimitersImpl(grammar, rule) FOR this-»
«ENDDEFINE»

«DEFINE createDelimiters(Grammar grammar) FOR RuleCall-»
«EXPAND createDelimitersImpl(grammar, rule) FOR this-»
«ENDDEFINE»

«DEFINE createDelimiters(Grammar grammar) FOR Keyword-»
«LET sameConflicts(grammar) AS first-»
«IF first == this-»
«LET conflictingLexerRules(grammar) AS conflicting-»
«IF !conflicting.isEmpty-»
    // TODO: remove hardcoded character class from template
	public static ICharacterClass «globalDelimiterFieldName()» = ICharacterClass.Factory.join(
			ICharacterClass.Factory.createRange('a', 'z'),
			ICharacterClass.Factory.createRange('A', 'Z'),
			ICharacterClass.Factory.create('_'),
			ICharacterClass.Factory.createRange('0', '9')
	);
«ELSE-»
	public static ICharacterClass «globalDelimiterFieldName()» = ICharacterClass.Factory.nullClass();
«ENDIF-»

«ENDLET-»
«ENDIF-»
«ENDLET-»
«ENDDEFINE»