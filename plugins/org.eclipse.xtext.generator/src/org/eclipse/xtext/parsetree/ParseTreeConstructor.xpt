«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»

«EXTENSION org::eclipse::xtext::grammargen::GrammarGen»
«EXTENSION org::eclipse::xtext::parsetree::ParseTreeConstructor»
«EXTENSION org::eclipse::xtext::XtextUtil»
«EXTENSION org::openarchitectureware::util::stdlib::collections»
«EXTENSION org::openarchitectureware::util::stdlib::io»

«DEFINE file FOR Grammar»
«FILE pathName()+'/'+languageName()+'ParseTreeConstructor.java'»
package «packageName()»;

import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.*;
import org.eclipse.emf.ecore.EObject;

public class «languageName()»ParseTreeConstructor extends AbstractParseTreeConstructor {
   
	protected void internalDoUpdate(EObject obj, String ruleToCall) {
		«FOREACH parserRules AS pr SEPARATOR ' else '-»
		if (ruleToCall.equals("«pr.name»")) {
			«pr.methodName()»(getDescr(obj));
		}«ENDFOREACH» else {
			throw new IllegalArgumentException("Couldn't find rule '"+ruleToCall+"'");
		}
	}

	«EXPAND method FOREACH parserRules»
}
«ENDFILE»
«ENDDEFINE»

«DEFINE method FOR ParserRule»
protected void «methodName()»(InstanceDescription obj) {
	«EXPAND statement FOR this.alternatives»
}
«ENDDEFINE»


«DEFINE statement FOR AbstractElement»
/* «metaType.name» */ 
«IF isOptional() && checkPath()!=null»
«cardinality=='?'?'if':'while'» («FOREACH checkPath() AS p SEPARATOR '||'»
new Predicate(obj) { 
		public boolean check() {
			return «p»; 
		}
}.check() «ENDFOREACH»)«ENDIF»{
«EXPAND statement2 FOR this»
}
«ENDDEFINE»

«DEFINE statement2 FOR AbstractElement»//Do nothing for '«metaType.name»'\n«ENDDEFINE»
«DEFINE statement2 FOR Assignment»
	final Object value = obj.consume("«feature»");
    «EXPAND statement FOR terminal»
    if (obj.isConsumed())
    	objectCreation(obj);
«ENDDEFINE»

«DEFINE statement2 FOR Keyword»
	keyword((Keyword)getGrammar().eResource().getEObject("«getFragment()»"));
«ENDDEFINE»

«DEFINE statement2 FOR Action»
	InstanceDescription newObj = getDescr((EObject) obj.consume("«feature»"));
	action(obj,newObj, (Action) getGrammar().eResource().getEObject("«getFragment()»"));
	obj = newObj;
«ENDDEFINE»

«DEFINE statement2 FOR RuleCall»
	«IF calledParserRule()!=null»
	InstanceDescription val = «isAssigned() ? '(getDescr((EObject)value))' : 'obj'»;
	EObject ruleCall = getGrammar().eResource().getEObject("«getFragment()»");
	try {
		ruleCallStart(val, «isAssigned()», (RuleCall) ruleCall);
		«calledRule().methodName()»(val);
	} finally {
		ruleCallEnd(val, «isAssigned()», (RuleCall) ruleCall);
	}
	«ELSE»
		«IF isAssigned()»
		lexerRuleCall(value,(RuleCall)getGrammar().eResource().getEObject("«getFragment()»"));
		«ELSE»
		lexerRuleCall((RuleCall)getGrammar().eResource().getEObject("«getFragment()»"));
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE statement2 FOR Group»
	«FOREACH (List[AbstractElement]) abstractTokens.inverse() AS t-»
		«EXPAND statement FOR t»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE statement2 FOR Alternatives»
	«FOREACH this.groups AS alt SEPARATOR "else"-»
		if («FOREACH alt.checkPath() AS p SEPARATOR '||'»
new Predicate(obj) { 
		public boolean check() {
			return «p»; 
		}
}.check() «ENDFOREACH») {
			«EXPAND statement FOR alt»
		}
	«ENDFOREACH-»
	«IF !isOptional()»
		else {
		    throw new IllegalStateException("No alternative matched");
		}
	«ENDIF»
«ENDDEFINE»



