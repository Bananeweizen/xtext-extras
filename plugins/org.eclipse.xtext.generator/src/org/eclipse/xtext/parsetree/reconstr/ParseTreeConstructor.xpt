«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»
«IMPORT xtextgen»

«EXTENSION org::eclipse::xtext::Extensions»
«EXTENSION org::eclipse::xtext::Properties»
«EXTENSION org::eclipse::xtext::parsetree::reconstr::ParseTreeConstructor»
«EXTENSION org::eclipse::xtext::XtextUtil»
«EXTENSION org::eclipse::xtend::util::stdlib::collections»
«EXTENSION org::eclipse::xtend::util::stdlib::io»

«DEFINE root FOR GenService»
«FILE genClassFQName.toJavaFilePath()-»
/*
«fileHeader()»
*/
package «genClassFQName.toJavaPackage()»;


import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.*;
import org.eclipse.xtext.parsetree.reconstr.impl.*;

public class «genClassFQName.toSimpleName()» extends AbstractParseTreeConstructor {

	protected void internalDoUpdate(EObject obj, String ruleToCall, IParseTreeConstructorCallback callback) {
		«FOREACH grammar().allParserRules() AS pr SEPARATOR ' else '-»
		if (ruleToCall.equals("«pr.name»")) {
			«pr.methodName()»(getDescr(obj),callback);
		}«ENDFOREACH» else {
			throw new XtextSerializationException(getDescr(obj), "Couldn't find rule '"+ruleToCall+"'");
		}
	}

	«EXPAND method FOREACH grammar().allParserRules()»
}
«ENDFILE»
«ENDDEFINE»

«DEFINE method FOR ParserRule»
private String «name»RecursionCheck = null;
protected void «methodName()»(InstanceDescription obj,IParseTreeConstructorCallback callback) {
	try {
		String s = obj.uniqueStateString();
		if (s.equals(«name»RecursionCheck))
			throw new XtextSerializationException(obj, obj.getDelegate()+" couldn't be serialized.");
		«name»RecursionCheck = s;
	«EXPAND statement FOR this.alternatives»
	} finally {
		«name»RecursionCheck = null;
	}
}
«ENDDEFINE»


«DEFINE statement FOR AbstractElement»
/* «metaType.name» */ 
«IF isOptional() && checkPath()!=null»
«cardinality=='?'?'if':'while'» («FOREACH checkPath() AS p SEPARATOR '||'»
new Predicate(obj) { 
		public boolean check() {
			return «p»; 
		}
}.check() «ENDFOREACH»)«ENDIF»{
«EXPAND statement2 FOR this»
}
«ENDDEFINE»

«DEFINE statement2 FOR AbstractElement»//Do nothing for '«metaType.name»'\n«ENDDEFINE»
«DEFINE statement2 FOR Assignment»
	final Object value = obj.consume("«feature»");
    «EXPAND statement FOR terminal»
    if (obj.isConsumed())
    	callback.objectCreation(obj);
«ENDDEFINE»

«DEFINE statement2 FOR Keyword»
	callback.keywordCall(obj,(Keyword)getGrammarElement("«objectURI()»"));
«ENDDEFINE»

«DEFINE statement2 FOR Action»
	InstanceDescription newObj = getDescr((EObject) obj.consume("«feature»"));
	callback.actionCall(obj, newObj, (Action) getGrammarElement("«objectURI()»"));
	obj = newObj;
«ENDDEFINE»

«DEFINE statement2 FOR RuleCall»
	«IF calledParserRule()!=null»
		InstanceDescription val = «isAssigned() ? '(getDescr((EObject)value))' : 'obj'»;
		EObject ruleCall = getGrammarElement("«objectURI()»");
		try {
			callback.parserRuleCallStart(val, (RuleCall) ruleCall);
			«calledRule().methodName()»(val,callback);
			«IF isAssigned()»
			if (!val.isConsumed()) 
				throw new XtextSerializationException(val,"unserialized state");
			«ENDIF»
		} finally {
			callback.parserRuleCallEnd();
		}
	«ELSE»
		callback.lexerRuleCall(obj,(RuleCall)getGrammarElement("«objectURI()»"));
	«ENDIF»
«ENDDEFINE»

«DEFINE statement2 FOR Group»
	«FOREACH (List[AbstractElement]) abstractTokens.inverse() AS t-»
		«EXPAND statement FOR t»
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE statement2 FOR Alternatives»
	«FOREACH this.groups AS alt SEPARATOR "else"-»
		if («FOREACH alt.checkPath() AS p SEPARATOR '||'»
new Predicate(obj) { 
		public boolean check() {
			return «p»; 
		}
}.check() «ENDFOREACH») {
			«EXPAND statement FOR alt»
		}
	«ENDFOREACH-»
	«IF !isOptional()»
		else {
		    throw new XtextSerializationException(obj, "No alternative matched");
		}
	«ENDIF»
«ENDDEFINE»



