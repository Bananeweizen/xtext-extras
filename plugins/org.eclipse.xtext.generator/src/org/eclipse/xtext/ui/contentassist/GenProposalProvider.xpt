«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT xtext»
«IMPORT xtextgen»

«EXTENSION org::eclipse::xtend::util::stdlib::globalvar»
«EXTENSION org::eclipse::xtext::Extensions»
«EXTENSION org::eclipse::xtext::Properties»
«EXTENSION org::eclipse::xtext::ui::UIProperties»

«DEFINE root FOR GenModel»
«FILE uiGenProposalProviderClass().toJavaFilePath() UI_SRC_GEN -»
/*
«fileHeader()»
*/
package «uiGenProposalProviderClass().toJavaPackage()»;

import java.util.Collections;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.ui.common.editor.codecompletion.AbstractProposalProvider;
import org.eclipse.xtext.ui.common.editor.codecompletion.IProposalProvider;

/**
 * Represents a generated, default implementation of interface {@link IProposalProvider}.
 * 
 * In addition to the declared methods, the framework tries to call grammar dependent methods for assignments using reflection.
 * The signature of such methods invoked reflectively follows the following pattern:
 * 
 * public List<ICompletionProposal> complete[Typename][featureName](Assignment ele, EObject model, String prefix)
 * 
 * <b>Example</b>
 *  Given the following grammar :
 *  <code>
 *  RuleA returns MyType :
 *  	"myType" name=ID;
 *  </code>
 *
 * One could provide the following method in an implementation of this interface:
 *  <code>
 * 	public List<ICompletionProposal> completeMyTypeName(Assignment ele, EObject model, String prefix, IDocument doc) {...}
 *  </code>
 *  Note that if you have generated Java classes for your domain model (meta model) you can alternatively declare the second parameter using 
 *  a specific type:
 *  <code>
 * 	public List<ICompletionProposal> completeMyTypeName(Assignment ele, MyType model, String prefix, IDocument doc) {...}
 *  </code>
 *   
 */
public class «uiGenProposalProviderClass().toSimpleName()»  extends AbstractProposalProvider {
	// constants
	private static final String UI_PLUGIN_ID  = "«uiPluginBundleID»";

	«FOREACH grammar().containedAssignments() AS assignment-»
	«LET assignment.containingParserRule().name.toFirstUpper()+assignment.feature.toFirstUpper() AS fqnFeatureName»
	«IF null==getGlobalVar(fqnFeatureName)-»
	«storeGlobalVar(fqnFeatureName,"")-»	 
	public List<? extends ICompletionProposal> complete«fqnFeatureName»(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {
		if (logger.isDebugEnabled()) {
			logger.debug("complete«fqnFeatureName» feature '" + assignment.getFeature() + "' terminal '"
					+ assignment.getTerminal() + "' cardinality '" + assignment.getCardinality() + "' and prefix '"
					+ prefix.trim() + "'");
		}
		«IF CrossReference.isInstance(assignment.terminal)-»
		return lookupCrossReference(((CrossReference)assignment.getTerminal()), model, prefix, offset);
		«ELSEIF RuleCall.isInstance(assignment.terminal) && ((RuleCall)assignment.terminal).rule.name=="ID" -»
		return Collections.singletonList(createCompletionProposal(assignment,model,"«fqnFeatureName»", offset));
		«ELSEIF RuleCall.isInstance(assignment.terminal) && ((RuleCall)assignment.terminal).rule.name=="INT" -»
		return Collections.singletonList(createCompletionProposal(assignment,model,"1", offset));		
		«ELSEIF RuleCall.isInstance(assignment.terminal) && ((RuleCall)assignment.terminal).rule.name=="STRING" -»
		return Collections.singletonList(createCompletionProposal(assignment,model,"\"«fqnFeatureName»\"", offset));		
		«ELSE-»
		return Collections.emptyList();
		«ENDIF-»
	}
	«ENDIF-»
	«ENDLET-»
    «ENDFOREACH-»
    
    «FOREACH grammar().allParserRules().select(parserRule|parserRule.type!=null) AS parserRule-»
    «LET parserRule.type.metamodel.alias.toFirstUpper()+parserRule.type.type.name.toFirstUpper() AS fqnFeatureName»
	«IF null==getGlobalVar(fqnFeatureName)-»
	«storeGlobalVar(fqnFeatureName,"")-»	 
	public List<? extends ICompletionProposal> complete«fqnFeatureName»(RuleCall ruleCall, EObject model, String prefix,
			IDocument doc, int offset) {
		if (logger.isDebugEnabled()) {
			logger.debug("complete«fqnFeatureName» '" + ruleCall.getRule().getName() + "' cardinality '" + ruleCall.getCardinality()
					+ "' for model '" + model + "' and prefix '" + prefix.trim() + "'");
		}
		return Collections.emptyList();
	}
	«ENDIF-»
	«ENDLET-»
    «ENDFOREACH-»
    @Override
	protected String getDefaultImageFilePath() {
		return "icons/editor.gif";
	}

	@Override
	protected String getPluginId() {
		return UI_PLUGIN_ID;
	}
}
«ENDFILE»
«ENDDEFINE»

