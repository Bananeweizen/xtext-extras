/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
language org.eclipse.xtext.XtextGrammarTest

generate XtextTest "http://www.eclipse.org/2008/Test/XtextTest"

Grammar  :
	((abstract?='abstract language' | 'language') idElements+=ID ('.' idElements+=ID)* ('extends' superGrammarIdElements+=ID ('.' superGrammarIdElements+=ID)*)?)?
	metamodelDeclarations+=AbstractMetamodelDeclaration* 
    parserRules+=ParserRule*
    ('lexing' ':'
    lexerRules+=LexerRule+)?
;

AbstractRule : LexerRule | ParserRule;

AbstractMetamodelDeclaration :
	GeneratedMetamodel | ReferencedMetamodel;
	
GeneratedMetamodel :
	'generate' name=ID nsURI=STRING ('as' alias=ID)?;

ReferencedMetamodel :
	'import' uri=STRING ('as' alias=ID)?;

LexerRule  :
	name=ID ('returns' type=TypeRef)? ':' 
	body=STRING
;

ParserRule :
    name=ID ('returns' type=TypeRef)? ':' 
    	alternatives=Alternatives   
    ';'
;

TypeRef :
	(alias=ID '::')? name=ID
;
Alternatives returns AbstractElement:
    Group ({Alternatives.groups+=current} '|' groups+=Group)*
;

Group returns AbstractElement:
    AbstractToken ( {current=Group.abstractTokens+=current} abstractTokens+=AbstractToken)*
;

AbstractToken returns AbstractElement:
	(Assignment | 
	 Action |
	 AbstractTerminal) cardinality=('?'|'*'|'+')?;

Assignment returns Assignment:
   feature=ID operator=('+='|'='|'?=') terminal=AbstractTerminal;

Action returns Action:
	'{' ('current' '=')? typeName=TypeRef ('.' feature=ID operator=('='|'+=') 'current')? '}';

AbstractTerminal returns AbstractElement: 
   Keyword | RuleCall | ParenthesizedElement
;

ParenthesizedElement returns AbstractElement:
   '(' Alternatives ')'
;

Keyword : 
   value=STRING 
;

RuleCall :
   name=ID ;
   
// lexing:

// Problem: LEXER_BODY kann nicht in xtxt beschrieben werden, da das erste '#>' bereits matcht
// Lösung: built-in lexer token
// LEXER_BODY : <# '<#' ( options {greedy=false;} : . )* '#>' #> 
